#define GLSL 1
#define Texture2DArray uniform sampler2DArray
#define cbuffer uniform
#define float4x4 mat4
#define float4   vec4
#define float3   vec3
#include "camera.fxh"
#include "material.fxh"

precision highp float;
precision highp int;

layout(input_attachment_index = 0, binding = 0) uniform highp subpassInput sp_colorTexture;
layout(input_attachment_index = 1, binding = 1) uniform highp subpassInput sp_depthTexture;
layout(input_attachment_index = 2, binding = 2) uniform highp subpassInput sp_normalTexture;
layout(input_attachment_index = 3, binding = 3) uniform highp subpassInput sp_materialTexture;

layout(location = 0) out vec4 out_Color;

///////////////////////////////////////////////////////////
struct DirLight {
    vec4 color;
    vec4 direction;
};

///////////////////////////////////////////////////////////
uniform Lights {
    vec4 g_ambient;
    DirLight g_dirLights[MAX_NUM_DIR_LIGHTS];
    int g_numDirLights;
};

///////////////////////////////////////////////////////////
vec3 getFragPos(float depth) {
    vec2 uv = gl_FragCoord.xy * g_viewport.zw;
    vec4 clipPos = vec4(uv * vec2(2.0, -2.0) + vec2(-1.0, 1.0), depth, 1.0f);
    vec4 pos = g_invProjView * clipPos;

    return pos.xyz / pos.w;
}

///////////////////////////////////////////////////////////
// const vec3 emissionColor = vec3(1.0, 1.0, 1.0);
// const vec3 rimColor = vec3(1.0, 1.0, 1.0);         // White rim light for now
// const float rimPower = 3.0f;                  // Rim light power

void main() {
    float depth = subpassLoad(sp_depthTexture).x;
    if (depth == 1.0) {
        // Discard background pixels
        discard;
    }

    // Load subpass
    vec4 diffuseRougness = subpassLoad(sp_colorTexture);
    vec4 normalEmmisive = subpassLoad(sp_normalTexture);
    vec4 materialProps = subpassLoad(sp_materialTexture);

    vec3 albedo = diffuseRougness.rgb;
    vec3 normal = normalEmmisive.xyz;
    float emission = normalEmmisive.w;
    float rim = materialProps.g;
    Material material = getMaterial(materialProps.a);

    // Base color
    vec3 result = albedo * g_ambient.rgb;

    for (int i = 0; i < g_numDirLights; ++i) {
        float diffFactor = 0.1f;

        // Get diffuse factor
        float diff = dot(normal, -g_dirLights[i].direction.xyz);
        float diff1 = diffFactor * diff + diffFactor;
        float diff2 = (1.0f - diffFactor) * diff + diffFactor;
        diff = diff < 0.0f ? diff1 : diff2;
        
        // Diffuse color
        vec3 diffuse = diff * g_dirLights[i].color.rgb * albedo;
        
        // Add to result
        result += diffuse;
    }
    
    // Get view vector
    vec3 worldPos = getFragPos(depth);
    vec3 viewPos = g_cameraPos.xyz;
    vec3 V = normalize(viewPos - worldPos);

    // === Rim lighting ===
    float rimBase = 1.0 - max(dot(normal, V), 0.0);
    float rimAmount = rim * pow(rimBase, material.rimPower);
    vec3 rimLight = material.rimColor * rimAmount;

    // Emissive
    vec3 emissionLight = albedo * material.emissionColor * emission;

    result += emissionLight + rimLight;
    
    out_Color = vec4(result, 1.0);
}